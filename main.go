package main // プログラムの実行を開始するメインパッケージを宣言します。

import (
	"fmt" // フォーマットされたI/O（主にメッセージ出力）を行うためのパッケージです。
	"net" // ネットワークI/O（TCP/UDP通信など）を扱うためのパッケージです。
)

// main関数は、プログラムが実行されたときに最初に呼び出される特別な関数です。
func main() {
	// サーバーが待ち受けを開始することをコンソールに出力します。
	// Redisの標準ポートである6379番を使います。
	fmt.Println("Listening on port :6379")

	// ----------------------------------------------------
	// 1. サーバーソケット（待ち受け口）の作成
	// ----------------------------------------------------

	// net.Listenを使って、TCPプロトコルで ":6379"（全てのネットワークインターフェースの6379番ポート）で
	// 新しい接続を待ち受けるリスナー（待ち受けソケット）を作成します。
	l, err := net.Listen("tcp", ":6379")
	if err != nil {
		// リスナーの作成に失敗した場合（例: ポートが既に使用されている）は、エラーを出力してプログラムを終了します。
		fmt.Println(err)
		return
	}

	// ----------------------------------------------------
	// 2. クライアントからの接続を待つ
	// ----------------------------------------------------

	// l.Accept() は、新しいクライアント接続が来るまで処理をブロック（停止）します。
	// 接続が確立されると、その接続を表す `conn`（net.Connインターフェース）が返されます。
	conn, err := l.Accept()
	if err != nil {
		// 接続の受け入れ中にエラーが発生した場合、エラーを出力してプログラムを終了します。
		fmt.Println(err)
		return
	}

	// defer conn.Close()
	// defer は、この関数 (main) の処理が終了する直前に conn.Close() を実行するように予約します。
	// これにより、プログラムが正常終了してもエラーで終了しても、必ず接続が閉じられることが保証されます。
	defer conn.Close()

	// ----------------------------------------------------
	// 3. 通信ループ（データの読み書き）
	// ----------------------------------------------------

	// クライアントとの接続が確立された後、データを継続的に処理するための無限ループに入ります。
	for {
		// --- データの読み取り (Read) ---

		// 接続 (conn) を使って新しい RESP パーサー（リーダー）を作成します。
		resp := NewResp(conn)

		// resp.Read() を呼び出して、クライアントから送られてきたRESP形式のデータを読み取り、Value構造体にパースします。
		value, err := resp.Read()
		if err != nil {
			// データ読み取り中にエラーが発生した場合（クライアント切断など）は、ループを抜けてプログラムを終了します。
			fmt.Println(err)
			return
		}

		// _ = value
		// 受信した Value を変数に代入していますが、このサーバーはリクエスト内容を無視するため、
		// 変数を使っていないことによるコンパイラ警告を避けるために `_ =` で代入しています。
		_ = value

		// --- 応答の書き出し (Write) ---

		// 接続 (conn) を使って新しい RESP Writer（書き出し側）を作成します。
		writer := NewWriter(conn)

		// Simple String の "OK" に対応する Value 構造体を作成し、Writerに渡して送信します。
		// Writer.Write() の内部で Value は "+OK\r\n" という RESPバイト列に変換され、クライアントに送信されます。
		err = writer.Write(Value{typ: "string", str: "OK"})
		if err != nil {
			// 書き込みエラーが発生した場合もプログラムを終了します。
			fmt.Println(err)
			return
		}
	}
}
