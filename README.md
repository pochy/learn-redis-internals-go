# Redis互換TCPサーバー - Go言語実装

## プロジェクト概要

この **Golang** のプログラムは、非常にシンプルな **TCPサーバー** として機能し、**Redis** の通信プロトコルである **RESP (REdis Serialization Protocol)** を使ってクライアントからの命令を受け取り、固定の応答を返す一連の流れを実装しています。

> **参考資料**: このプロジェクトは [Build Redis from scratch](https://www.build-redis-from-scratch.dev/en/introduction) のチュートリアルを参考に作成されています。Redisの内部動作を理解し、データベースの低レベルな詳細を学習することを目的としています。

### 学習目標
- TCPサーバーの基本的な仕組みを理解する
- RESPプロトコルの解析方法を学ぶ
- Go言語でのネットワークプログラミングの基礎を習得する
- Redisクライアントとの通信の仕組みを理解する

### 前提知識
- Go言語の基本的な構文（構造体、メソッド、エラーハンドリング）
- ネットワークの基本的な概念（TCP、ポート、ソケット）
- Redisの基本的な使い方（redis-cliコマンド）

---

## 目次
1. [プロジェクト構成](#プロジェクト構成)
2. [サーバーの起動と待ち受け](#1-サーバーの起動と待ち受けmain-関数開始)
3. [クライアント接続の受け入れ](#2-クライアント接続の受け入れ)
4. [データの読み書きループ](#3-データの読み書きループサーバーの主な処理)
5. [RESPプロトコルパーサーの詳細](#resp-redis-serialization-protocol-パーサーの詳細解説)
6. [実行方法とテスト](#実行方法とテスト)
7. [トラブルシューティング](#トラブルシューティング)

---

## プロジェクト構成

```
build-your-own-redis-go/
├── main.go          # TCPサーバーのメインロジック
├── resp.go          # RESPプロトコルパーサー
└── README.md        # このファイル
```

### ファイルの役割
- **main.go**: TCPサーバーの起動、クライアント接続の受け入れ、通信ループの管理
- **resp.go**: RESPプロトコルで送信されるデータの解析（パース）機能
- **README.md**: プロジェクトの詳細な説明と学習ガイド

---

## 1. サーバーの起動と待ち受け（`main` 関数開始）

-----

## 1\. サーバーの起動と待ち受け（`main` 関数開始）

プログラムの実行は `main` 関数から始まります。ここでは、サーバーがどのように起動し、クライアントからの接続を待つ準備をするかを詳しく見ていきます。

### 1.1 メッセージの出力
```go
fmt.Println("Listening on port :6379")
```

**何をしているか:**
- コンソールに「ポート **6379** で待ち受けを開始する」というメッセージを出力
- サーバーが起動中であることをユーザーに知らせる
- デバッグやログの目的でも使用される

**なぜ6379番ポートなのか:**
- Redisの標準ポート番号
- 他のRedisクライアント（redis-cliなど）がデフォルトで接続を試みるポート
- ポート番号は0-65535の範囲で、1024以下はシステム用に予約されている

### 1.2 TCPリスナーの作成
```go
l, err := net.Listen("tcp", ":6379")
```

**`net.Listen`関数の詳細:**
- **第1引数 "tcp"**: 通信プロトコルとして **TCP (Transmission Control Protocol)** を指定
  - TCPは信頼性の高い通信プロトコル（データの順序保証、再送機能など）
  - HTTP、HTTPS、Redisなど多くのアプリケーションで使用
- **第2引数 ":6379"**: サーバーが接続を待つアドレスとポートを指定
  - `:` の前が空 = すべてのネットワークインターフェース（外部からの接続も受け入れ）
  - `6379` = Redisのデフォルトポート番号

**戻り値:**
- `l` (リスナー): 成功時に返される `net.Listener` インターフェース
- `err` (エラー): 失敗時に返されるエラー情報

**実際の動作:**
1. オペレーティングシステムに「6379番ポートで接続を待ち受けてください」と依頼
2. OSがポートをバインド（占有）し、接続要求を待機
3. 成功するとリスナーオブジェクトが返される

### 1.3 エラー処理
```go
if err != nil {
    fmt.Println(err)
    return
}
```

**エラーが発生する可能性のあるケース:**
- **ポートが既に使用中**: 他のプログラム（本物のRedisサーバーなど）が6379番ポートを使用している
- **権限不足**: 1024番以下のポートを使用する場合に管理者権限が必要
- **ネットワーク設定の問題**: ファイアウォールやネットワーク設定による制限

**エラーハンドリングの重要性:**
- プログラムが予期しない動作を防ぐ
- ユーザーに問題の原因を伝える
- リソースの適切な解放を保証する

-----

## 2. クライアント接続の受け入れ

サーバーは、リスナーが作成されると、クライアントからの接続を待ちます。ここでは、クライアントが接続してきた時の処理を詳しく見ていきます。

### 2.1 接続のブロックと待機
```go
conn, err := l.Accept()
```

**`l.Accept()`の動作:**
- 新しいクライアントがサーバーに接続してくるまで、プログラムの実行を **一時停止（ブロック）** します
- これは**同期処理**で、接続が来るまで他の処理は実行されません
- クライアント（`redis-cli`や別のプログラム）が接続を試みると、接続が確立されます

**戻り値:**
- `conn` (コネクション): `net.Conn`インターフェースを実装したオブジェクト
  - クライアントとの間で実際にデータをやり取りするための「**通信路**」
  - `Read()`、`Write()`、`Close()`などのメソッドを持つ
- `err` (エラー): 接続受け入れ中に発生したエラー

**接続の確立プロセス:**
1. クライアントがサーバーのIPアドレスとポート（6379）に接続要求を送信
2. OSのネットワークスタックが接続要求を受け取り
3. `Accept()`が接続を確立し、通信路を作成
4. サーバーとクライアント間でデータの送受信が可能になる

### 2.2 エラー処理
```go
if err != nil {
    fmt.Println(err)
    return
}
```

**接続受け入れでエラーが発生するケース:**
- **ネットワークエラー**: ネットワークの障害や設定の問題
- **リソース不足**: システムのメモリやファイルディスクリプタの不足
- **セキュリティ制限**: ファイアウォールやセキュリティポリシーによる制限
- **サーバーの停止**: サーバープロセスが終了している

### 2.3 接続のクリーンアップ予約
```go
defer conn.Close()
```

**`defer`キーワードの詳細:**
- `defer`は、この`main`関数が **終了する直前** に、指定された処理を必ず実行するように予約します
- 関数の終了方法に関係なく実行される（正常終了、エラー終了、panicなど）
- **LIFO（Last In, First Out）**の順序で実行される

**なぜ`defer`を使うのか:**
- **リソースリークの防止**: 接続を適切に閉じることで、システムリソースを解放
- **確実なクリーンアップ**: プログラムが予期しない終了をしても接続が閉じられる
- **コードの簡潔性**: エラー処理の各箇所で`Close()`を書く必要がない

**実際の動作:**
1. `defer conn.Close()`が実行され、関数終了時の処理として登録される
2. `main`関数が終了する直前（`return`の実行時）に`conn.Close()`が呼び出される
3. TCP接続が適切に閉じられ、リソースが解放される

-----

## 3. データの読み書きループ（サーバーの主な処理）

接続が確立されたら、`for {}` の **無限ループ** に入り、クライアントとのデータのやり取りを継続します。これがサーバーの核となる処理です。

### 3.1 RESPパーサーの初期化
```go
resp := NewResp(conn)
```

**`NewResp`関数の役割:**
- クライアントとの通信路 `conn` を使って、RESPプロトコル形式のデータを解析するための `Resp` オブジェクトを新しく作成
- `bufio.Reader`でラップすることで、効率的なデータ読み取りを実現
- ループの各反復で新しいパーサーインスタンスを作成（状態のリセット）

**なぜループ内で毎回作成するのか:**
- パーサーの状態をリセットして、前回の処理の影響を排除
- 各リクエストを独立して処理するため
- エラーが発生した場合の影響を最小限に抑える

### 3.2 クライアントデータの読み取りと解析
```go
value, err := resp.Read()
```

**`resp.Read()`の動作:**
- クライアントから送信された **RESP形式のデータ**（例：`*2\r\n$4\r\nPING\r\n$4\r\nTEST\r\n`）を読み取り
- バイナリデータをGoの `Value` 構造体に変換（パース）
- この処理は、クライアントがデータを送信するまでブロックされる

**RESPデータの例:**
```
*2\r\n$4\r\nPING\r\n$4\r\nTEST\r\n
```
- `*2`: 2つの要素を持つ配列
- `$4\r\nPING\r\n`: 4文字のバルク文字列 "PING"
- `$4\r\nTEST\r\n`: 4文字のバルク文字列 "TEST"

**パース結果:**
```go
Value{
    typ: "array",
    array: [
        Value{typ: "bulk", bulk: "PING"},
        Value{typ: "bulk", bulk: "TEST"}
    ]
}
```

### 3.3 読み取りエラー処理
```go
if err != nil {
    fmt.Println(err)
    return
}
```

**エラーが発生する主なケース:**
- **`io.EOF`**: クライアントが接続を閉じた（最も一般的）
- **ネットワークエラー**: 接続の切断やタイムアウト
- **不正なデータ形式**: RESPプロトコルに準拠しないデータ
- **リソース不足**: メモリ不足など

**エラーハンドリングの戦略:**
- エラーをログに出力して問題を特定
- `return`でプログラムを終了（単一接続サーバーのため）
- `defer conn.Close()`により接続のクリーンアップが保証される

### 3.4 受信データの出力（デバッグ用）
```go
fmt.Println(value)
```

**デバッグ出力の目的:**
- クライアントから受信したデータが正しくパースされているかを確認
- 開発時の動作確認とトラブルシューティング
- RESPプロトコルの学習と理解の促進

**出力例:**
```
{array [{bulk PING} {bulk TEST}]}
```

### 3.5 固定応答の送信
```go
conn.Write([]byte("+OK\r\n"))
```

**応答の詳細:**
- 受信したデータの内容に関係なく、サーバーはクライアントに対して **"+OK\r\n"** という **固定の応答** を送り返します
- これは RESP の **Simple String** 形式の応答
- `+` は Simple String のプレフィックス
- `OK` は成功を表すメッセージ
- `\r\n` は RESPプロトコルで必須の改行コード

**`conn.Write()`の動作:**
- バイトデータ (`[]byte`) を使って応答をクライアントに送信
- ネットワーク経由でクライアントにデータが届く
- 書き込みが完了するまでブロックされる

**実際の通信フロー:**
1. クライアント: `*2\r\n$4\r\nPING\r\n$4\r\nTEST\r\n` を送信
2. サーバー: データを受信・パース
3. サーバー: `+OK\r\n` を送信
4. クライアント: 応答を受信
5. ループが継続し、次のリクエストを待機

-----

## 4. プログラムの終了

無限ループが終了条件（接続切断エラーなど）を満たした場合、`main` 関数が終了します。

### 4.1 終了プロセス
1. **エラー発生時**: `resp.Read()`でエラーが発生し、`return`が実行される
2. **`defer`の実行**: `defer conn.Close()`が実行され、クライアントとの接続が正式に閉じられる
3. **リソース解放**: TCP接続、ファイルディスクリプタなどのシステムリソースが解放される
4. **プログラム終了**: `main`関数が終了し、プログラムが完全に終了する

### 4.2 このサーバーの特徴
このプログラムは、クライアントとの接続を一つだけ処理する、**最も基本的な単一接続のサーバー** の例です。

**制限事項:**
- 同時に1つのクライアント接続しか処理できない
- クライアントが切断すると、サーバーも終了する
- 実際のRedisサーバーとは異なり、データの永続化や複雑なコマンド処理は行わない

**実際のサーバーとの違い:**
- 実際のサーバーは、通常、複数のクライアント接続を同時に処理するために、**並行処理（ゴルーチン）** を使います
- 本格的なサーバーでは、データベース機能、認証、ログ機能などが追加されます

---

## RESP (REdis Serialization Protocol) パーサーの詳細解説

**RESP (REdis Serialization Protocol) パーサー** のコア部分である `Resp` 構造体のメソッド（関数）について、データの読み取りから解析までの流れを詳細に解説します。

このパーサーは、ネットワーク接続から流れてくるバイトデータを、意味のある **Value** 構造体（RESPデータ型）に変換する役割を担っています。

-----

### 5.1 パーサーの準備と基本的な読み取り

パーサーがクライアントとの通信路からデータを取得する、最も基本的な処理です。

#### 5.1.1 初期化 (`NewResp`)

```go
func NewResp(rd io.Reader) *Resp {
    return &Resp{reader: bufio.NewReader(rd)}
}
```

**この関数の役割:**
- パーサーを作成するコンストラクタ関数
- ネットワーク接続 (`io.Reader`) を受け取り、それを **`bufio.Reader`** でラップ（包んで）します

**`bufio.Reader`の利点:**
- **バッファリング** を行うことで、ネットワークからバイトを一つずつ読み取る際の効率を大幅に向上
- システムコールの回数を減らし、パフォーマンスを向上
- 内部バッファにデータを蓄積し、必要に応じて提供

**実際の動作:**
1. `io.Reader`インターフェースを受け取る（`net.Conn`など）
2. `bufio.NewReader()`でバッファリングされたリーダーを作成
3. `Resp`構造体のインスタンスを作成して返す

#### 5.1.2 行末までの読み取り (`readLine`)

```go
func (r *Resp) readLine() (line []byte, n int, err error) { /* ... */ }
```

**RESPプロトコルの改行規則:**
- ほとんどのデータ型（文字列の長さ、整数の値など）は、データ本体の後に **CRLF**（`\r\n`、キャリッジリターンとラインフィード）という改行コードが続く
- これはHTTPプロトコルと同じ改行コード形式

**`readLine`メソッドの動作:**
1. `bufio.Reader` の `ReadByte()` を使ってバイトを一つずつ読み込み
2. 読み込んだバイトを `line` スライスに追加
3. 行の末尾が `\r\n` であることを検出すると、読み込みを終了
4. 最終的に、**`\r\n` を除いた** データ本体のバイトスライス（`line[:len(line)-2]`）を返す

**戻り値:**
- `line`: CRLFを除いたデータ本体
- `n`: 読み込んだ総バイト数（CRLF含む）
- `err`: エラー情報

#### 5.1.3 整数値の読み取りと変換 (`readInteger`)

```go
func (r *Resp) readInteger() (x int, n int, err error) { /* ... */ }
```

**このメソッドの用途:**
- RESPで使われる **長さ情報** や **整数型** の値を解析
- 配列の要素数、バルク文字列の長さなどに使用

**処理の流れ:**
1. `r.readLine()` を呼び出し、整数の文字列表現（例: "3" や "1024"）を取得
2. **`strconv.ParseInt`** を使用して、取得したバイトスライス（文字列）を実際の数値 (`int64`) に変換
3. その数値を `int` 型として返す

**エラーハンドリング:**
- 文字列が数値として解釈できない場合、エラーを返す
- オーバーフローやアンダーフローの場合もエラーとして処理

-----

### 5.2 メインのパース処理 (`Read`)

クライアントから送られてきたデータの解析は、この `Read` メソッドから始まります。

```go
func (r *Resp) Read() (Value, error) {
    _type, err := r.reader.ReadByte()
    if err != nil {
        return Value{}, err
    }
    
    switch _type {
    case ARRAY:
        return r.readArray()
    case BULK:
        return r.readBulk()
    default:
        fmt.Printf("Unknown type: %v", string(_type))
        return Value{}, nil
    }
}
```

#### 5.2.1 最初のバイトの読み取り
```go
_type, err := r.reader.ReadByte()
```

**RESPプロトコルの型識別:**
- `r.reader.ReadByte()` を使って、データの型を示す **最初の1バイト**（**プレフィックス**）を読み取る
- RESPでは、この1バイトがデータ型を決定する：
  - `*` = 配列（ARRAY）
  - `$` = バルク文字列（BULK）
  - `+` = シンプル文字列（STRING）
  - `-` = エラー（ERROR）
  - `:` = 整数（INTEGER）

#### 5.2.2 型の判別と処理振り分け
```go
switch _type {
case ARRAY:
    return r.readArray()
case BULK:
    return r.readBulk()
default:
    fmt.Printf("Unknown type: %v", string(_type))
    return Value{}, nil
}
```

**処理の流れ:**
1. 読み取ったプレフィックス（`_type`）に基づき、`switch` 文で適切な解析メソッドに処理を振り分け
2. `*` の場合は `readArray()` を呼び出し
3. `$` の場合は `readBulk()` を呼び出し
4. 未知の型の場合はエラーメッセージを出力

**エラーハンドリング:**
- データの終わり（EOF）などのエラーがあれば即座に返す
- 未知の型の場合は警告を出力して空のValueを返す

-----

## 3\. 複合データ型の解析

### 3.1. 配列の解析 (`readArray`)

RESPの **配列** (`*` で始まるデータ) は、他のデータ型（バルク文字列など）を要素として含む、**複合的なデータ型** です。

1.  **型と要素数の読み取り**:
      * `v.typ = "array"` を設定します。
      * `r.readInteger()` を呼び出し、配列に含まれる **要素の数 (len)** を読み取ります。
2.  **要素の反復処理**:
      * 要素数 `len` の回数だけ `for` ループを回します。
3.  **再帰的な呼び出し**:
      * ループ内で、再び **`r.Read()`** メソッドを呼び出します。これが **再帰的な処理** の要点です。配列の要素は、バルク文字列かもしれないし、さらに別の配列かもしれません。`Read()` が要素のプレフィックスを読み取り、適切な解析を行います。
4.  **要素の格納**:
      * 解析された要素 (`val`) を配列のリスト (`v.array`) に追加（`append`）し、すべての要素が処理されるまでこれを繰り返します。

### 3.2. バルク文字列の解析 (`readBulk`)

RESPの **バルク文字列** (`$` で始まるデータ) は、クライアントからサーバーへ送信されるコマンド引数など、まとまったデータに使われます。

1.  **長さの読み取り**:
      * `r.readInteger()` を呼び出し、バルク文字列の **バイト数（長さ）** を読み取ります。
2.  **データ本体の読み取り**:
      * 読み取った長さ (`len`) のバイトスライス (`bulk`) を作成します。
      * `r.reader.Read(bulk)` を呼び出し、**正確にその長さ分だけ** のデータをネットワークから読み込み、`bulk` スライスに格納します。
3.  **文字列への変換**:
      * 読み込んだバイトスライスを Go の `string` 型に変換し、`v.bulk` に格納します。
4.  **CRLFの読み捨て**:
      * バルク文字列のデータ本体の **直後** には、必ず **末尾の CRLF** があります。これをスキップ（読み捨て）するために、`r.readLine()` を **戻り値を無視して** 呼び出します。

### 5.3 複合データ型の解析

#### 5.3.1 配列の解析 (`readArray`)

RESPの **配列** (`*` で始まるデータ) は、他のデータ型（バルク文字列など）を要素として含む、**複合的なデータ型** です。

```go
func (r *Resp) readArray() (Value, error) {
    v := Value{}
    v.typ = "array"
    
    len, _, err := r.readInteger()
    if err != nil {
        return v, err
    }
    
    v.array = make([]Value, 0)
    for i := 0; i < len; i++ {
        val, err := r.Read()
        if err != nil {
            return v, err
        }
        v.array = append(v.array, val)
    }
    
    return v, nil
}
```

**処理の詳細:**

1. **型と要素数の読み取り**:
   - `v.typ = "array"` を設定してValueの型を指定
   - `r.readInteger()` を呼び出し、配列に含まれる **要素の数 (len)** を読み取る

2. **要素の反復処理**:
   - 要素数 `len` の回数だけ `for` ループを実行
   - `make([]Value, 0)` で空のスライスを作成（容量0で初期化）

3. **再帰的な呼び出し**:
   - ループ内で、再び **`r.Read()`** メソッドを呼び出し
   - これが **再帰的な処理** の要点：配列の要素は、バルク文字列かもしれないし、さらに別の配列かもしれない
   - `Read()` が要素のプレフィックスを読み取り、適切な解析を行う

4. **要素の格納**:
   - 解析された要素 (`val`) を配列のリスト (`v.array`) に追加（`append`）
   - すべての要素が処理されるまでこれを繰り返す

**配列の例:**
```
*2\r\n$4\r\nPING\r\n$4\r\nTEST\r\n
```
- `*2`: 2つの要素を持つ配列
- `$4\r\nPING\r\n`: 1番目の要素（バルク文字列 "PING"）
- `$4\r\nTEST\r\n`: 2番目の要素（バルク文字列 "TEST"）

#### 5.3.2 バルク文字列の解析 (`readBulk`)

RESPの **バルク文字列** (`$` で始まるデータ) は、クライアントからサーバーへ送信されるコマンド引数など、まとまったデータに使われます。

```go
func (r *Resp) readBulk() (Value, error) {
    v := Value{}
    v.typ = "bulk"
    
    len, _, err := r.readInteger()
    if err != nil {
        return v, err
    }
    
    bulk := make([]byte, len)
    r.reader.Read(bulk)
    v.bulk = string(bulk)
    
    r.readLine()
    
    return v, nil
}
```

**処理の詳細:**

1. **長さの読み取り**:
   - `r.readInteger()` を呼び出し、バルク文字列の **バイト数（長さ）** を読み取る
   - この長さは、データ本体のバイト数を表す

2. **データ本体の読み取り**:
   - 読み取った長さ (`len`) のバイトスライス (`bulk`) を作成
   - `r.reader.Read(bulk)` を呼び出し、**正確にその長さ分だけ** のデータをネットワークから読み込み
   - `bulk` スライスに格納される

3. **文字列への変換**:
   - 読み込んだバイトスライスを Go の `string` 型に変換
   - `v.bulk` に格納する

4. **CRLFの読み捨て**:
   - バルク文字列のデータ本体の **直後** には、必ず **末尾の CRLF** がある
   - これをスキップ（読み捨て）するために、`r.readLine()` を **戻り値を無視して** 呼び出す

**バルク文字列の例:**
```
$4\r\nPING\r\n
```
- `$4`: 4バイトのバルク文字列
- `\r\n`: 長さの後のCRLF
- `PING`: データ本体（4バイト）
- `\r\n`: データ本体の後のCRLF

### 5.4 パーサーの動作まとめ

この一連の流れにより、サーバーはネットワーク通信路から流れてくるバイナリデータを、Goの `Value` 構造体に綺麗に分解・格納することができます。

**パーサーの特徴:**
- **再帰的**: 配列の要素として他の配列やバルク文字列を含むことができる
- **型安全**: 各データ型に応じた適切な処理を行う
- **エラーハンドリング**: 不正なデータやネットワークエラーに対応
- **効率的**: バッファリングによりネットワークI/Oを最適化

---

## 6. 実行方法とテスト

### 6.1 サーバーの起動

```bash
# プロジェクトディレクトリに移動
cd /path/to/build-your-own-redis-go

# Goプログラムを実行
go run main.go resp.go
```

**期待される出力:**
```
Listening on port :6379
```

### 6.2 クライアントでのテスト

**別のターミナルでredis-cliを使用:**
```bash
# Redisクライアントで接続
redis-cli -p 6379

# コマンドを送信
127.0.0.1:6379> PING
OK
127.0.0.1:6379> SET key value
OK
127.0.0.1:6379> GET key
OK
```

**サーバー側の出力例:**
```
{array [{bulk PING}]}
{array [{bulk SET} {bulk key} {bulk value}]}
{array [{bulk GET} {bulk key}]}
```

### 6.3 telnetでのテスト

```bash
# telnetで接続
telnet localhost 6379

# RESP形式でコマンドを送信
*2
$4
PING
$4
TEST
```

**期待される応答:**
```
+OK
```

---

## 7. トラブルシューティング

### 7.1 よくある問題

**ポートが既に使用されている:**
```
listen tcp :6379: bind: address already in use
```
- 解決方法: 他のRedisサーバーが動いている場合は停止するか、別のポートを使用

**権限不足:**
```
listen tcp :6379: bind: permission denied
```
- 解決方法: 管理者権限で実行するか、1024番以上のポートを使用

**接続が拒否される:**
```
dial tcp 127.0.0.1:6379: connect: connection refused
```
- 解決方法: サーバーが起動しているか確認

### 7.2 デバッグのヒント

1. **サーバー側のログを確認**: 受信したデータが正しくパースされているか
2. **ネットワーク接続を確認**: `netstat -an | grep 6379`でポートの状態を確認
3. **クライアント側のエラーを確認**: redis-cliのエラーメッセージを確認

### 7.3 パフォーマンスの考慮事項

- この実装は教育目的のため、パフォーマンスは最適化されていません
- 実際の本番環境では、並行処理（ゴルーチン）やコネクションプールの使用を検討
- バッファサイズの調整やメモリプールの使用も有効

---

## 参考資料・関連リンク

- **[Build Redis from scratch](https://www.build-redis-from-scratch.dev/en/introduction)**: このプロジェクトの主要な参考資料
- **[Redis Protocol Specification](https://redis.io/docs/reference/protocol-spec/)**: RESPプロトコルの公式仕様
- **[Go net package documentation](https://pkg.go.dev/net)**: Go言語のネットワークプログラミング
- **[bufio package documentation](https://pkg.go.dev/bufio)**: Go言語のバッファリングI/O

### さらなる学習のために

このプロジェクトは、Redisの内部動作を理解するための第一歩です。より高度な機能を実装したい場合は、以下の要素を追加することを検討してください：

- **データ永続化**: AOF（Append Only File）やRDBファイルの実装
- **複数データ型**: 文字列、ハッシュ、リスト、セット、ソート済みセットのサポート
- **並行処理**: ゴルーチンを使った複数接続の同時処理
- **メモリ管理**: 効率的なデータ構造とメモリ使用量の最適化
- **コマンド処理**: 実際のRedisコマンドの実装